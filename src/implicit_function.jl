"""
    ImplicitFunction

Wrapper for an implicit function defined by a forward mapping `y` and a set of conditions `c`.

An `ImplicitFunction` object behaves like a function, and every call is differentiable with respect to the first argument `x`.
When a derivative is queried, the Jacobian of `y` is computed using the implicit function theorem:

    ∂/∂y c(x, y(x)) * ∂/∂x y(x) = -∂/∂x c(x, y(x))

This requires solving a linear system `A * J = -B` where `A = ∂c/∂y`, `B = ∂c/∂x` and `J = ∂y/∂x`.

# Fields

- `forward`: a callable, does not need to be compatible with automatic differentiation
- `conditions`: a callable, must be compatible with automatic differentiation
- `linear_solver`: a subtype of `AbstractLinearSolver`, defines how the linear system will be solved
- `conditions_x_backend`: either `nothing` or a subtype of `ADTypes.AbstractADType`, defines how the conditions will be differentiated with respect to the first argument `x` 
- `conditions_y_backend`: same for the second argument `y`

There are two possible signatures for `forward` and `conditions`, which must be consistent with one another:
    
1. Standard: `forward(x, args...; kwargs...) = y` and `conditions(x, y, args...; kwargs...) = c`
2. Byproduct: `forward(x, args...; kwargs...) = (y, z)` and `conditions(x, y, z, args...; kwargs...) = c`.
    
In both cases, `x`, `y` and `c` must be arrays, with `size(y) = size(c)`.
In the second case, the byproduct `z` can be an arbitrary object generated by `forward`.
The positional arguments `args...` and keyword arguments `kwargs...` must be the same for both `forward` and `conditions`.

!!! warning "Warning"
    The byproduct `z` and the other positional arguments `args...` beyond `x` are considered constant for differentiation purposes.
"""
@kwdef struct ImplicitFunction{
    F,C,L,B1<:Union{Nothing,AbstractADType},B2<:Union{Nothing,AbstractADType}
}
    forward::F
    conditions::C
    linear_solver::L = first ∘ gmres
    conditions_x_backend::B1 = nothing
    conditions_y_backend::B2 = nothing
end

function ImplicitFunction(forward, conditions; kwargs...)
    return ImplicitFunction(; forward, conditions, kwargs...)
end

function Base.show(io::IO, implicit::ImplicitFunction)
    (; forward, conditions, linear_solver, conditions_x_backend, conditions_y_backend) =
        implicit
    return print(
        io,
        "ImplicitFunction($forward, $conditions, $linear_solver, $conditions_x_backend, $conditions_y_backend)",
    )
end

"""
    (implicit::ImplicitFunction)(x::AbstractArray, args...; kwargs...)

Return `implicit.forward(x, args...; kwargs...)`, which can be either an array `y` or a tuple `(y, z)`.

This call is differentiable (except for `z`).
"""
function (implicit::ImplicitFunction)(x::AbstractVector, args...; kwargs...)
    y_or_yz = implicit.forward(x, args...; kwargs...)
    if !(y_or_yz isa Union{AbstractArray,Tuple{<:AbstractVector,<:Any}})
        error(
            "The forward mapping must return a vector `y` or a tuple `(y, z)` where `y` is a vector",
        )
    end
    return y_or_yz
end

get_output(y::AbstractVector) = y
get_byproduct(y::AbstractVector) = error("No byproduct")
get_output(yz::Tuple{<:AbstractVector,<:Any}) = yz[1]
get_byproduct(yz::Tuple{<:AbstractVector,<:Any}) = yz[2]
