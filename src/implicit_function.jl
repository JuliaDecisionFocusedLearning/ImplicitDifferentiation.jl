"""
    ImplicitFunction{FF,CC,LS}

Differentiable wrapper for an implicit function defined by a forward mapping and a set of conditions.

# Constructors

You can construct an `ImplicitFunction` from a forward mapping `f` and conditions `c`, both of which must be callables (function-like objects).
While `f` does not not need to be compatible with automatic differentiation, `c` has to be.

    ImplicitFunction(
        f, c[, HandleByproduct()];
        linear_solver=IterativeLinearSolver()
    )

# Callable behavior

An `ImplicitFunction` object `implicit` behaves like a function, and every call to it is differentiable.
    
    implicit(x::AbstractArray[, ReturnByproduct()]; kwargs...)

# Details

- By default, we assume that the forward mapping is `x -> y(x)` and the conditions are `c(x,y(x)) = 0`.
- If `HandleByproduct()` is passed as an argument to the constructor, we assume instead that the forward mapping is `x -> (y(x),z(x))` and the conditions are `c(x,y(x),z(x)) = 0`. In this case, `z(x)` can contain additional information generated by the forward mapping, but beware that we consider it constant for differentiation purposes.

Given `x ∈ ℝⁿ` and `y ∈ ℝᵈ`, we need as many conditions as output dimensions: `c(x,y,z) ∈ ℝᵈ`. We can then compute the Jacobian of `y(⋅)` using the implicit function theorem:

    ∂₂c(x,y(x),z(x)) * ∂y(x) = -∂₁c(x,y(x),z(x))

This requires solving a linear system `A * J = -B`, where `A ∈ ℝᵈˣᵈ`, `B ∈ ℝᵈˣⁿ` and `J ∈ ℝᵈˣⁿ`.

# Fields

- `forward::FF`: a wrapper of type [`Forward`](@ref) around the callable `f`
- `conditions::CC`: a wrapper of type [`Conditions`](@ref) around the callable `c`
- `linear_solver::LS`: an object subtyping [`AbstractLinearSolver`](@ref).
"""
struct ImplicitFunction{FF<:Forward,CC<:Conditions,LS<:AbstractLinearSolver}
    forward::FF
    conditions::CC
    linear_solver::LS

    function ImplicitFunction(f, c; linear_solver::AbstractLinearSolver)
        forward = Forward{false}(f)
        conditions = Conditions{false}(c)
        return new{typeof(forward),typeof(conditions),typeof(linear_solver)}(
            forward, conditions, linear_solver
        )
    end

    function ImplicitFunction(f, c, ::HandleByproduct; linear_solver::AbstractLinearSolver)
        forward = Forward{true}(f)
        conditions = Conditions{true}(c)
        return new{typeof(forward),typeof(conditions),typeof(linear_solver)}(
            forward, conditions, linear_solver
        )
    end
end

function Base.show(io::IO, implicit::ImplicitFunction)
    @unpack forward, conditions, linear_solver = implicit
    return print(io, "ImplicitFunction($(forward.f), $(conditions.c), $linear_solver)")
end

function (implicit::ImplicitFunction)(x::AbstractArray; kwargs...)
    y, z = implicit.forward(x; kwargs...)
    return y
end

function (implicit::ImplicitFunction)(x::AbstractArray, ::ReturnByproduct; kwargs...)
    y, z = implicit.forward(x; kwargs...)
    return (y, z)
end

function handles_byproduct(implicit::ImplicitFunction)
    return handles_byproduct(implicit.forward) && handles_byproduct(implicit.conditions)
end
