"""
    ImplicitFunction{FF,CC,LS}

Differentiable wrapper for an implicit function defined by a forward mapping and a set of conditions.

# Constructors

    ImplicitFunction(f, c)
    ImplicitFunction(f, c, linear_solver)
    ImplicitFunction(f, c, HandleByproduct())
    ImplicitFunction(f, c, linear_solver, HandleByproduct())

Construct an `ImplicitFunction` from a forward mapping `f` and conditions `c`, both of which are Julia callables.
While `f` does not not need to be compatible with automatic differentiation, `c` has to be.

# Details

- By default, we assume that the forward mapping is `x -> y(x)` and the conditions are `c(x,y(x)) = 0`.
- If `handleByproduct()` is passed as an argument to the constructor, we assume instead that the forward mapping is `x -> (y(x),z(x))` and the conditions are `c(x,y(x),z(x)) = 0`. In this case, `z(x)` can contain additional information generated by the forward mapping, but beware that we consider it constant for differentiation purposes.

Given `x ∈ ℝⁿ` and `y ∈ ℝᵈ`, we need as many conditions as output dimensions: `c(x,y,z) ∈ ℝᵈ`. We can then compute the Jacobian of `y(⋅)` using the implicit function theorem:
```
∂₂c(x,y(x),z(x)) * ∂y(x) = -∂₁c(x,y(x),z(x))
```
This requires solving a linear system `A * J = -B`, where `A ∈ ℝᵈˣᵈ`, `B ∈ ℝᵈˣⁿ` and `J ∈ ℝᵈˣⁿ`.

# Fields

- `forward::FF`: a wrapper of type [`Forward`](@ref) around the callable `f`
- `conditions::CC`: a wrapper of type [`Conditions`](@ref) around the callable `c`
- `linear_solver::LS`: an object subtyping [`AbstractLinearSolver`](@ref) (defaults to [`IterativeLinearSolver`](@ref)).
"""
struct ImplicitFunction{FF<:Forward,CC<:Conditions,LS<:AbstractLinearSolver}
    forward::FF
    conditions::CC
    linear_solver::LS

    function ImplicitFunction(f, c, linear_solver::AbstractLinearSolver)
        forward = Forward{false}(f)
        conditions = Conditions{false}(c)
        return new{typeof(forward),typeof(conditions),typeof(linear_solver)}(
            forward, conditions, linear_solver
        )
    end

    function ImplicitFunction(f, c, linear_solver::AbstractLinearSolver, ::HandleByproduct)
        forward = Forward{true}(f)
        conditions = Conditions{true}(c)
        return new{typeof(forward),typeof(conditions),typeof(linear_solver)}(
            forward, conditions, linear_solver
        )
    end
end

function ImplicitFunction(f, c)
    linear_solver = IterativeLinearSolver()
    return ImplicitFunction(f, c, linear_solver)
end

function ImplicitFunction(f, c, ::HandleByproduct)
    linear_solver = IterativeLinearSolver()
    return ImplicitFunction(f, c, linear_solver, HandleByproduct())
end

function Base.show(io::IO, implicit::ImplicitFunction)
    @unpack forward, conditions, linear_solver = implicit
    return print(io, "ImplicitFunction($(forward.f), $(conditions.c), $linear_solver)")
end

"""
    implicit(x::AbstractArray; kwargs...)

Make an [`ImplicitFunction`](@ref) callable by applying the forward mapping `implicit.forward`.
"""
function (implicit::ImplicitFunction)(x::AbstractArray, ; kwargs...)
    y, z = implicit.forward(x, ; kwargs...)
    return y
end

"""
    implicit(x::AbstractArray, ReturnByproduct(); kwargs...)

Make an [`ImplicitFunction`](@ref) callable by applying the forward mapping `implicit.forward` and returning the byproduct.
"""
function (implicit::ImplicitFunction)(x::AbstractArray, ::ReturnByproduct; kwargs...)
    y, z = implicit.forward(x, ; kwargs...)
    return (y, z)
end
