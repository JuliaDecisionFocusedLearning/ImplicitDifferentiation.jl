<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic use cases · ImplicitDifferentiation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://gdalle.github.io/ImplicitDifferentiation.jl/examples/1_basic/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImplicitDifferentiation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../0_intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Basic use cases</a><ul class="internal"><li><a class="tocitem" href="#Unconstrained-optimization"><span>Unconstrained optimization</span></a></li><li><a class="tocitem" href="#Nonlinear-system"><span>Nonlinear system</span></a></li><li><a class="tocitem" href="#Fixed-point"><span>Fixed point</span></a></li></ul></li><li><a class="tocitem" href="../2_advanced/">Advanced use cases</a></li><li><a class="tocitem" href="../3_tricks/">Tricks</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Basic use cases</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic use cases</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gdalle/ImplicitDifferentiation.jl/blob/9770882e2db0c190647c4b3871552f5a8a913ee5/examples/1_basic.jl#" title="View on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">View on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-use-cases"><a class="docs-heading-anchor" href="#Basic-use-cases">Basic use cases</a><a id="Basic-use-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-use-cases" title="Permalink"></a></h1><p>We show how to differentiate through very common routines:</p><ul><li>an unconstrained optimization problem</li><li>a nonlinear system of equations</li><li>a fixed point iteration</li></ul><pre><code class="language-julia hljs">using ForwardDiff
using ImplicitDifferentiation
using LinearAlgebra
using NLsolve
using Optim
using Random
using Zygote

Random.seed!(63);</code></pre><p>In all three cases, we will use the square root as our forward mapping, but expressed in three different ways. Here&#39;s our heroic test vector:</p><pre><code class="language-julia hljs">x = rand(2);</code></pre><p>Since we already know the mathematical expression of the Jacobian, we will be able to compare it with our numerical results.</p><pre><code class="language-julia hljs">J = Diagonal(0.5 ./ sqrt.(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:
 1.05545   ⋅ 
  ⋅       0.874736</code></pre><h2 id="Unconstrained-optimization"><a class="docs-heading-anchor" href="#Unconstrained-optimization">Unconstrained optimization</a><a id="Unconstrained-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Unconstrained-optimization" title="Permalink"></a></h2><p>First, we show how to differentiate through the solution of an unconstrained optimization problem:</p><p class="math-container">\[y(x) = \underset{y \in \mathbb{R}^m}{\mathrm{argmin}} ~ f(x, y)\]</p><p>The optimality conditions are given by gradient stationarity:</p><p class="math-container">\[\nabla_2 f(x, y) = 0\]</p><p>To make verification easy, we minimize the following objective:</p><p class="math-container">\[f(x, y) = \lVert y \odot y - x \rVert^2\]</p><p>In this case, the optimization problem boils down to the componentwise square root function, but we implement it using a black box solver from <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>. Note the presence of a keyword argument.</p><pre><code class="language-julia hljs">function forward_optim(x; method)
    f(y) = sum(abs2, y .^ 2 .- x)
    y0 = ones(eltype(x), size(x))
    result = optimize(f, y0, method)
    return Optim.minimizer(result)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">forward_optim (generic function with 1 method)</code></pre><p>Even though they are defined as a gradient, it is better to provide optimality conditions explicitly: that way we avoid nesting autodiff calls. By default, the conditions should accept two arguments as input. The forward mapping and the conditions should accept the same set of keyword arguments.</p><pre><code class="language-julia hljs">function conditions_optim(x, y; method)
    ∇₂f = @. 4 * (y^2 - x) * y
    return ∇₂f
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">conditions_optim (generic function with 1 method)</code></pre><p>We now have all the ingredients to construct our implicit function.</p><pre><code class="language-julia hljs">implicit_optim = ImplicitFunction(forward_optim, conditions_optim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ImplicitFunction(forward_optim, conditions_optim, IterativeLinearSolver(true), nothing)</code></pre><p>And indeed, it behaves as it should when we call it:</p><pre><code class="language-julia hljs">implicit_optim(x; method=LBFGS()) .^ 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.22442135282677544
 0.3267275093803709</code></pre><p>Forward mode autodiff</p><pre><code class="language-julia hljs">ForwardDiff.jacobian(_x -&gt; implicit_optim(_x; method=LBFGS()), x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.05545  0.0
 0.0      0.874736</code></pre><p>In this instance, we could use ForwardDiff.jl directly on the solver, but it returns the wrong result (not sure why).</p><pre><code class="language-julia hljs">ForwardDiff.jacobian(_x -&gt; forward_optim(x; method=LBFGS()), x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0</code></pre><p>Reverse mode autodiff</p><pre><code class="language-julia hljs">Zygote.jacobian(_x -&gt; implicit_optim(_x; method=LBFGS()), x)[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
  1.05545  -0.0
 -0.0       0.874736</code></pre><p>In this instance, we cannot use Zygote.jl directly on the solver (due to unsupported <code>try/catch</code> statements).</p><pre><code class="language-julia hljs">try
    Zygote.jacobian(_x -&gt; forward_optim(x; method=LBFGS()), x)[1]
catch e
    e
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Zygote.CompileError(Tuple{typeof(Optim.perform_linesearch!), Optim.LBFGSState{Vector{Float64}, Vector{Vector{Float64}}, Vector{Vector{Float64}}, Float64, Vector{Float64}}, Optim.LBFGS{Nothing, LineSearches.InitialStatic{Float64}, LineSearches.HagerZhang{Float64, Base.RefValue{Bool}}, Optim.var&quot;#19#21&quot;}, Optim.ManifoldObjective{NLSolversBase.OnceDifferentiable{Float64, Vector{Float64}, Vector{Float64}}}}, ErrorException(&quot;try/catch is not supported.\nRefer to the Zygote documentation for fixes.\nhttps://fluxml.ai/Zygote.jl/latest/limitations\n&quot;))</code></pre><h2 id="Nonlinear-system"><a class="docs-heading-anchor" href="#Nonlinear-system">Nonlinear system</a><a id="Nonlinear-system-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-system" title="Permalink"></a></h2><p>Next, we show how to differentiate through the solution of a nonlinear system of equations:</p><p class="math-container">\[\text{find} \quad y(x) \quad \text{such that} \quad F(x, y(x)) = 0\]</p><p>The optimality conditions are pretty obvious:</p><p class="math-container">\[F(x, y) = 0\]</p><p>To make verification easy, we solve the following system:</p><p class="math-container">\[F(x, y) = y \odot y - x = 0\]</p><p>In this case, the optimization problem boils down to the componentwise square root function, but we implement it using a black box solver from <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a>.</p><pre><code class="language-julia hljs">function forward_nlsolve(x; method)
    F!(storage, y) = (storage .= y .^ 2 .- x)
    initial_y = similar(x)
    initial_y .= 1
    result = nlsolve(F!, initial_y; method)
    return result.zero
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">forward_nlsolve (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">function conditions_nlsolve(x, y; method)
    c = y .^ 2 .- x
    return c
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">conditions_nlsolve (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">implicit_nlsolve = ImplicitFunction(forward_nlsolve, conditions_nlsolve)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ImplicitFunction(forward_nlsolve, conditions_nlsolve, IterativeLinearSolver(true), nothing)</code></pre><pre><code class="language-julia hljs">implicit_nlsolve(x; method=:newton) .^ 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.2244213528686593
 0.3267275094228514</code></pre><p>Forward mode autodiff</p><pre><code class="language-julia hljs">ForwardDiff.jacobian(_x -&gt; implicit_nlsolve(_x; method=:newton), x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.05545  0.0
 0.0      0.874736</code></pre><pre><code class="language-julia hljs">ForwardDiff.jacobian(_x -&gt; forward_nlsolve(_x; method=:newton), x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.05545  0.0
 0.0      0.874736</code></pre><p>Reverse mode autodiff</p><pre><code class="language-julia hljs">Zygote.jacobian(_x -&gt; implicit_nlsolve(_x; method=:newton), x)[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
  1.05545  -0.0
 -0.0       0.874736</code></pre><pre><code class="language-julia hljs">try
    Zygote.jacobian(_x -&gt; forward_nlsolve(_x; method=:newton), x)[1]
catch e
    e
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Zygote.CompileError(Tuple{typeof(NLsolve.newton_), NLSolversBase.OnceDifferentiable{Vector{Float64}, Matrix{Float64}, Vector{Float64}}, Vector{Float64}, Float64, Float64, Int64, Bool, Bool, Bool, LineSearches.Static, NLsolve.var&quot;#27#29&quot;, NLsolve.NewtonCache{Vector{Float64}}}, ErrorException(&quot;try/catch is not supported.\nRefer to the Zygote documentation for fixes.\nhttps://fluxml.ai/Zygote.jl/latest/limitations\n&quot;))</code></pre><h2 id="Fixed-point"><a class="docs-heading-anchor" href="#Fixed-point">Fixed point</a><a id="Fixed-point-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-point" title="Permalink"></a></h2><p>Finally, we show how to differentiate through the limit of a fixed point iteration:</p><p class="math-container">\[y \longmapsto T(x, y)\]</p><p>The optimality conditions are pretty obvious:</p><p class="math-container">\[y = T(x, y)\]</p><p>To make verification easy, we consider <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron&#39;s_method">Heron&#39;s method</a>:</p><p class="math-container">\[T(x, y) = \frac{1}{2} \left(y + \frac{x}{y}\right)\]</p><p>In this case, the fixed point algorithm boils down to the componentwise square root function, but we implement it manually.</p><pre><code class="language-julia hljs">function forward_fixedpoint(x; iterations)
    y = ones(eltype(x), size(x))
    for _ in 1:iterations
        y .= 0.5 .* (y .+ x ./ y)
    end
    return y
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">forward_fixedpoint (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">function conditions_fixedpoint(x, y; iterations)
    T = 0.5 .* (y .+ x ./ y)
    return T .- y
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">conditions_fixedpoint (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">implicit_fixedpoint = ImplicitFunction(forward_fixedpoint, conditions_fixedpoint)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ImplicitFunction(forward_fixedpoint, conditions_fixedpoint, IterativeLinearSolver(true), nothing)</code></pre><pre><code class="language-julia hljs">implicit_fixedpoint(x; iterations=10) .^ 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.22442135286865494
 0.3267275094228514</code></pre><p>Forward mode autodiff</p><pre><code class="language-julia hljs">ForwardDiff.jacobian(_x -&gt; implicit_fixedpoint(_x; iterations=10), x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.05545  0.0
 0.0      0.874736</code></pre><pre><code class="language-julia hljs">ForwardDiff.jacobian(_x -&gt; forward_fixedpoint(_x; iterations=10), x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.05545  0.0
 0.0      0.874736</code></pre><p>Reverse mode autodiff</p><pre><code class="language-julia hljs">Zygote.jacobian(_x -&gt; implicit_fixedpoint(_x; iterations=10), x)[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.05545  0.0
 0.0      0.874736</code></pre><pre><code class="language-julia hljs">try
    Zygote.jacobian(_x -&gt; forward_fixedpoint(_x; iterations=10), x)[1]
catch e
    e
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ErrorException(&quot;Mutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\nThis error occurs when you ask Zygote to differentiate operations that change\nthe elements of arrays in place (e.g. setting values with x .= ...)\n\nPossible fixes:\n- avoid mutating operations (preferred)\n- or read the documentation and solutions for this error\n  https://fluxml.ai/Zygote.jl/latest/limitations\n&quot;)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../0_intro/">« Introduction</a><a class="docs-footer-nextpage" href="../2_advanced/">Advanced use cases »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 10 August 2023 06:42">Thursday 10 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
