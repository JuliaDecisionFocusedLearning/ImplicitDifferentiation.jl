var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ImplicitDifferentiation]","category":"page"},{"location":"api/#ImplicitDifferentiation.ImplicitFunction","page":"API reference","title":"ImplicitDifferentiation.ImplicitFunction","text":"ImplicitFunction{F,C,L}\n\nDifferentiable wrapper for an implicit function x -> ŷ(x) whose output is defined by explicit conditions F(x,ŷ(x)) = 0.\n\nWe can obtain the Jacobian of ŷ with the implicit function theorem:\n\n∂₁F(x,ŷ(x)) + ∂₂F(x,ŷ(x)) * ∂ŷ(x) = 0\n\nIf x ∈ ℝⁿ, y ∈ ℝᵐ and F(x,y) ∈ ℝᶜ, this amounts to solving the linear system A * J = B, where A ∈ ℝᶜᵐ, B ∈ ℝᶜⁿ and J ∈ ℝᵐⁿ.\n\nFields:\n\nforward::F: callable of the form x -> ŷ(x)\nconditions::C: callable of the form (x,y) -> F(x,y)\nlinear_solver::L: callable of the form (A,b) -> u such that A * u = b\n\n\n\n\n\n","category":"type"},{"location":"api/#ImplicitDifferentiation.ImplicitFunction-Tuple{AbstractVector{<:Real}}","page":"API reference","title":"ImplicitDifferentiation.ImplicitFunction","text":"implicit(x)\n\nMake ImplicitFunction callable by applying implicit.forward.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainRulesCore.frule-Union{Tuple{R}, Tuple{ChainRulesCore.RuleConfig, Any, ImplicitFunction, AbstractVector{R}}} where R<:Real","page":"API reference","title":"ChainRulesCore.frule","text":"frule(rc, (_, dx), implicit, x)\n\nCustom forward rule for ImplicitFunction.\n\nWe compute the Jacobian-vector product Jv by solving Au = Bv and setting Jv = u.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainRulesCore.rrule-Union{Tuple{R}, Tuple{ChainRulesCore.RuleConfig, ImplicitFunction, AbstractVector{R}}} where R<:Real","page":"API reference","title":"ChainRulesCore.rrule","text":"rrule(rc, implicit, x)\n\nCustom reverse rule for ImplicitFunction.\n\nWe compute the vector-Jacobian product Jᵀv by solving Aᵀu = v and setting Jᵀv = Bᵀu.\n\n\n\n\n\n","category":"method"},{"location":"background/#Mathematical-background","page":"Mathematical background","title":"Mathematical background","text":"","category":"section"},{"location":"background/","page":"Mathematical background","title":"Mathematical background","text":"warning: Work in progress\nIn the meantime, please refer to the preprint Efficient and modular implicit differentiation for an introduction to the methods implemented here.","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/test/2_constrained_optimization.jl\"","category":"page"},{"location":"examples/2_constrained_optimization/#Constrained-optimization","page":"Constrained optimization","title":"Constrained optimization","text":"","category":"section"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"In this example, we show how to differentiate through the solution of the following constrained optimization problem:","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"haty(x) = min_y in mathcalC f(x y)","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"where mathcalC is a closed convex set. The optimal solution can be found as the fixed point of the projected gradient algorithm for any step size eta. This insight yields the following optimality conditions:","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"F(x haty(x)) = 0 quad textwith quad F(xy) = mathrmproj_mathcalC(y - eta nabla_2 f(x y)) - y","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"using ChainRulesCore\nusing ImplicitDifferentiation\nusing Ipopt\nusing JuMP\nusing Krylov: gmres\nusing Zygote","category":"page"},{"location":"examples/2_constrained_optimization/#Projecting-onto-the-simplex","page":"Constrained optimization","title":"Projecting onto the simplex","text":"","category":"section"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"We focus on minimizing f(xy) = lVert y - x rVert_2^2. We also assume that mathcalC = Delta^n is the n-dimensional probability simplex, because we know exact procedures to compute the projection and its Jacobian. See https://arxiv.org/abs/1602.02068 for details.","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"function simplex_projection_and_support(z::AbstractVector{<:Real})\n    d = length(z)\n    z_sorted = sort(z; rev=true)\n    z_sorted_cumsum = cumsum(z_sorted)\n    k = maximum(j for j in 1:d if (1 + j * z_sorted[j]) > z_sorted_cumsum[j])\n    τ = (z_sorted_cumsum[k] - 1) / k\n    p = max.(z .- τ, 0)\n    s = [Int(p[i] > eps()) for i in 1:d]\n    return p, s\nend;\n\nfunction simplex_projection(z::AbstractVector{<:Real})\n    p, _ = simplex_projection_and_support(z)\n    return p\nend;\nnothing #hide","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"Note that defining a custom chain rule for the projection is indeed necessary, since it contains a call to sort that Zygote cannot differentiate through.","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"function ChainRulesCore.rrule(::typeof(simplex_projection), z::AbstractVector{<:Real})\n    p, s = simplex_projection_and_support(z)\n    S = sum(s)\n    function simplex_projection_pullback(dp)\n        vjp = s .* (dp .- (dp's) / S)\n        return (NoTangent(), vjp)\n    end\n    return p, simplex_projection_pullback\nend;\nnothing #hide","category":"page"},{"location":"examples/2_constrained_optimization/#Implicit-function-wrapper","page":"Constrained optimization","title":"Implicit function wrapper","text":"","category":"section"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"We now wrap a black box optimizer inside an ImplicitFunction to compare its implicit differentiation with the explicit procedure given above.","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"function forward(x)\n    n = length(x)\n    model = Model(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0))\n    @variable(model, y[1:n] >= 0)\n    @constraint(model, sum(y) == 1)\n    @objective(model, Min, sum((y .- x) .^ 2))\n    optimize!(model)\n    return value.(y)\nend;\n\nconditions(x, y) = simplex_projection(y - 0.1*2(y - x)) - y;\n\nimplicit = ImplicitFunction(; forward=forward, conditions=conditions, linear_solver=gmres);\nnothing #hide","category":"page"},{"location":"examples/2_constrained_optimization/#Testing","page":"Constrained optimization","title":"Testing","text":"","category":"section"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"Let us study the behavior of our implicit function.","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"x = rand(10)","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"We can see that the forward pass computes the projection correctly, at least up to numerical precision.","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"hcat(simplex_projection(x), implicit(x))","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"And the same goes for the Jacobian.","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"cat(\n    Zygote.jacobian(simplex_projection, x)[1],\n    Zygote.jacobian(implicit, x)[1],\n    dims=3\n)","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"","category":"page"},{"location":"examples/2_constrained_optimization/","page":"Constrained optimization","title":"Constrained optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ImplicitDifferentiation","category":"page"},{"location":"#ImplicitDifferentiation.jl","page":"Home","title":"ImplicitDifferentiation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ImplicitDifferentiation.jl is a package for automatic differentiation of implicit functions.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install it, open a Julia Pkg REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add \"https://github.com/gdalle/ImplicitDifferentiation.jl\"","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/test/1_unconstrained_optimization.jl\"","category":"page"},{"location":"examples/1_unconstrained_optimization/#Unconstrained-optimization","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"","category":"section"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"In this example, we show how to differentiate through the solution of the following unconstrained optimization problem:","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"haty(x) = min_y in mathbbR^m f(x y)","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"The optimality conditions are given by gradient stationarity:","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"F(x haty(x)) = 0 quad textwith quad F(xy) = nabla_2 f(x y) = 0","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"using ImplicitDifferentiation\nusing Krylov: gmres\nusing Optim: optimize, minimizer, LBFGS\nusing Zygote","category":"page"},{"location":"examples/1_unconstrained_optimization/#Implicit-function-wrapper","page":"Unconstrained optimization","title":"Implicit function wrapper","text":"","category":"section"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"To make verification easy, we minimize a quadratic objective","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"f(x y) = lVert y - x rVert^2","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"In this case, the optimization algorithm is very simple, but still we can implement it as a black box to show that it doesn't change the result.","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"function forward(x)\n    f(y) = sum(abs2, y-x)\n    y0 = zero(x)\n    res = optimize(f, y0, LBFGS(); autodiff=:forward)\n    y = minimizer(res)\n    return y\nend;\nnothing #hide","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"On the other hand, optimality conditions should be provided explicitly whenever possible, so as to avoid nesting automatic differentiation calls.","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"conditions(x, y) = 2(y - x);\nnothing #hide","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"We now have all the ingredients to construct our implicit function.","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"implicit = ImplicitFunction(; forward=forward, conditions=conditions, linear_solver=gmres);\nnothing #hide","category":"page"},{"location":"examples/1_unconstrained_optimization/#Testing","page":"Unconstrained optimization","title":"Testing","text":"","category":"section"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"x = rand(10)","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"Let's start by taking a look at the forward pass, which should be the identity function.","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"implicit(x)","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"We now check whether the behavior of our ImplicitFunction wrapper is coherent with the theoretical derivatives.","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"Zygote.jacobian(implicit, x)[1]","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"As expected, we recover the identity matrix as Jacobian.","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"","category":"page"},{"location":"examples/1_unconstrained_optimization/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"This page was generated using Literate.jl.","category":"page"}]
}
