<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FAQ · ImplicitDifferentiation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://gdalle.github.io/ImplicitDifferentiation.jl/faq/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImplicitDifferentiation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/0_intro/">Introduction</a></li><li><a class="tocitem" href="../examples/1_basic/">Basic use cases</a></li><li><a class="tocitem" href="../examples/2_advanced/">Advanced use cases</a></li><li><a class="tocitem" href="../examples/3_tricks/">Tricks</a></li></ul></li><li><a class="tocitem" href="../api/">API reference</a></li><li class="is-active"><a class="tocitem" href>FAQ</a><ul class="internal"><li><a class="tocitem" href="#Supported-autodiff-backends"><span>Supported autodiff backends</span></a></li><li><a class="tocitem" href="#Writing-conditions"><span>Writing conditions</span></a></li><li><a class="tocitem" href="#Matrices-and-higher-order-arrays"><span>Matrices and higher-order arrays</span></a></li><li><a class="tocitem" href="#Scalars"><span>Scalars</span></a></li><li><a class="tocitem" href="#Multiple-inputs-/-outputs"><span>Multiple inputs / outputs</span></a></li><li><a class="tocitem" href="#Using-byproducts"><span>Using byproducts</span></a></li><li><a class="tocitem" href="#Performance-tips"><span>Performance tips</span></a></li><li><a class="tocitem" href="#Modeling-tips"><span>Modeling tips</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>FAQ</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FAQ</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gdalle/ImplicitDifferentiation.jl/blob/555259ff602de5c9c34623004f59f66708774bfc/docs/src/faq.md#" title="View on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">View on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Frequently-Asked-Questions"><a class="docs-heading-anchor" href="#Frequently-Asked-Questions">Frequently Asked Questions</a><a id="Frequently-Asked-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Frequently-Asked-Questions" title="Permalink"></a></h1><h2 id="Supported-autodiff-backends"><a class="docs-heading-anchor" href="#Supported-autodiff-backends">Supported autodiff backends</a><a id="Supported-autodiff-backends-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-autodiff-backends" title="Permalink"></a></h2><table><tr><th style="text-align: right">Backend</th><th style="text-align: right">Forward mode</th><th style="text-align: right">Reverse mode</th></tr><tr><td style="text-align: right"><a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a></td><td style="text-align: right">yes</td><td style="text-align: right">-</td></tr><tr><td style="text-align: right"><a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a>-compatible</td><td style="text-align: right">yes</td><td style="text-align: right">soon</td></tr><tr><td style="text-align: right"><a href="https://github.com/EnzymeAD/Enzyme.jl">Enzyme.jl</a></td><td style="text-align: right">someday</td><td style="text-align: right">someday</td></tr></table><h2 id="Writing-conditions"><a class="docs-heading-anchor" href="#Writing-conditions">Writing conditions</a><a id="Writing-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-conditions" title="Permalink"></a></h2><p>We recommend that the conditions themselves do not involve calls to autodiff, even when they describe a gradient. Otherwise, you will need to make sure that nested autodiff works well in your case. For instance, if you&#39;re differentiating your implicit function in reverse mode with Zygote.jl, you may want to use <a href="https://fluxml.ai/Zygote.jl/stable/utils/#Zygote.forwarddiff"><code>Zygote.forwarddiff</code></a> to wrap the conditions and differentiate them with ForwardDiff.jl instead.</p><h2 id="Matrices-and-higher-order-arrays"><a class="docs-heading-anchor" href="#Matrices-and-higher-order-arrays">Matrices and higher-order arrays</a><a id="Matrices-and-higher-order-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Matrices-and-higher-order-arrays" title="Permalink"></a></h2><p>For simplicity, our examples only display functions that eat and spit out vectors. However, arbitrary array shapes are supported, as long as the forward mapping <em>and</em> conditions return similar arrays. Beware however, sparse arrays will be densified in the differentiation process.</p><h2 id="Scalars"><a class="docs-heading-anchor" href="#Scalars">Scalars</a><a id="Scalars-1"></a><a class="docs-heading-anchor-permalink" href="#Scalars" title="Permalink"></a></h2><p>Functions that eat or spit out a single number are not supported. The forward mapping <em>and</em> conditions need arrays: for example, instead of returning <code>val</code> you should return <code>[val]</code> (a 1-element <code>Vector</code>).</p><h2 id="Multiple-inputs-/-outputs"><a class="docs-heading-anchor" href="#Multiple-inputs-/-outputs">Multiple inputs / outputs</a><a id="Multiple-inputs-/-outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-inputs-/-outputs" title="Permalink"></a></h2><p>In this package, implicit functions can only take a single input array <code>x</code> and output a single output array <code>y</code> (plus the byproduct <code>z</code>). But sometimes, your forward mapping or conditions may require multiple input arrays, say <code>a</code> and <code>b</code>:</p><pre><code class="language-julia hljs">function f(a, b)
    # do stuff
    return y, z
end</code></pre><p>In that case, you should gather the inputs inside a single <code>ComponentVector</code> from <a href="https://github.com/jonniedie/ComponentArrays.jl">ComponentArrays.jl</a> and define a new method:</p><pre><code class="language-julia hljs">f(x::ComponentVector) = f(x.a, x.b)</code></pre><p>The same trick works for multiple outputs.</p><h2 id="Using-byproducts"><a class="docs-heading-anchor" href="#Using-byproducts">Using byproducts</a><a id="Using-byproducts-1"></a><a class="docs-heading-anchor-permalink" href="#Using-byproducts" title="Permalink"></a></h2><p>Why would the forward mapping return a byproduct <code>z</code> in addition to <code>y</code>? It is mainly useful when the solution procedure creates objects such as Jacobians, which we want to reuse when computing or differentiating the conditions. In that case, you may want to write the differentiation rules yourself for the conditions. A more advanced application is given by <a href="https://github.com/gdalle/DifferentiableFrankWolfe.jl">DifferentiableFrankWolfe.jl</a>.</p><p>Keep in mind that derivatives of <code>z</code> will not be computed: the byproduct is considered constant during differentiation (unlike the case of multiple outputs outlined above).</p><h2 id="Performance-tips"><a class="docs-heading-anchor" href="#Performance-tips">Performance tips</a><a id="Performance-tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-tips" title="Permalink"></a></h2><p>If you work with small arrays (say, less than 100 elements), consider using <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> if you seek increased performance.</p><h2 id="Modeling-tips"><a class="docs-heading-anchor" href="#Modeling-tips">Modeling tips</a><a id="Modeling-tips-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-tips" title="Permalink"></a></h2><p>To express constrained optimization problems as implicit functions, you might need differentiable projections or proximal operators to write the optimality conditions. See <a href="https://arxiv.org/abs/2105.15183"><em>Efficient and modular implicit differentiation</em></a> for precise formulations.</p><p>In case these operators are too complicated to code them yourself, here are a few places you can look:</p><ul><li><a href="https://github.com/matbesancon/MathOptSetDistances.jl">MathOptSetDistances.jl</a></li><li><a href="https://github.com/JuliaFirstOrder/ProximalOperators.jl">ProximalOperators.jl</a></li></ul><p>An alternative is differentiating through the KKT conditions, which is exactly what <a href="https://github.com/jump-dev/DiffOpt.jl">DiffOpt.jl</a> does for JuMP models.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 31 July 2023 06:32">Monday 31 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
