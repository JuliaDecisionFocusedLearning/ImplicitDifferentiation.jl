var documenterSearchIndex = {"docs":
[{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/0_intro.jl\"","category":"page"},{"location":"examples/0_intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"We explain the basics of our package on a simple function that is not amenable to naive automatic differentiation.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/0_intro/#Why-do-we-bother?","page":"Introduction","title":"Why do we bother?","text":"","category":"section"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"ForwardDiff.jl and Zygote.jl are two prominent packages for automatic differentiation in Julia. While they are very generic, there are simple language constructs that they cannot differentiate through.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"function mysqrt(x::AbstractArray)\n    a = [0.0]\n    a[1] = first(x)\n    return sqrt.(x)\nend","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"This is essentially the componentwise square root function but with an additional twist: a::Vector{Float64} is created internally, and its only element is replaced with the first element of x. We can check that it does what it's supposed to do.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"x = rand(2)\nmysqrt(x) ≈ sqrt.(x)","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"Of course the Jacobian has an explicit formula.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"J = Diagonal(0.5 ./ sqrt.(x))","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"However, things start to go wrong when we compute it with autodiff, due to the limitations of ForwardDiff.jl and those of Zygote.jl.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"try\n    ForwardDiff.jacobian(mysqrt, x)\ncatch e\n    e\nend","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"ForwardDiff.jl throws an error because it tries to call mysqrt with an array of dual numbers, and cannot use one of these numbers to fill a (which has element type Float64).","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"try\n    Zygote.jacobian(mysqrt, x)\ncatch e\n    e\nend","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"Zygote.jl also throws an error because it cannot handle mutation.","category":"page"},{"location":"examples/0_intro/#Implicit-function","page":"Introduction","title":"Implicit function","text":"","category":"section"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"The first possible use of ImplicitDifferentiation.jl is to overcome the limitations of automatic differentiation packages by defining functions (and computing their derivatives) implicitly. An implicit function is a mapping","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"x in mathbbR^n longmapsto y(x) in mathbbR^m","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"whose output is defined by conditions","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"F(xy(x)) = 0 in mathbbR^m","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"We represent it using a type called ImplicitFunction, which you will see in action shortly.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"First we define a forward mapping correponding to the function we consider. It returns the actual output y(x) of the function, and can be thought of as a black box solver. Importantly, this Julia callable doesn't need to be differentiable by automatic differentiation packages but the underlying function still needs to be mathematically differentiable.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"forward(x) = mysqrt(x)","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"Then we define conditions c(x y) = 0 that the output y(x) is supposed to satisfy. These conditions must be array-valued, with the same size as y. Unlike the forward mapping, the conditions need to be differentiable by automatic differentiation packages with respect to both x and y. Here the conditions are very obvious: the square of the square root should be equal to the original value.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"function conditions(x, y)\n    c = y .^ 2 .- x\n    return c\nend","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"Finally, we construct a wrapper implicit around the previous objects. By default, forward is assumed to return a single output and conditions is assumed to accept 2 arguments.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"implicit = ImplicitFunction(forward, conditions)","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"What does this wrapper do? When we call it as a function, it just falls back on first ∘ implicit.forward, so unsurprisingly we get the first output y(x).","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"implicit(x) ≈ sqrt.(x)","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"And when we try to compute its Jacobian, the implicit function theorem is applied in the background to circumvent the lack of differentiablility of the forward mapping.","category":"page"},{"location":"examples/0_intro/#Forward-and-reverse-mode-autodiff","page":"Introduction","title":"Forward and reverse mode autodiff","text":"","category":"section"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"Now ForwardDiff.jl works seamlessly.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"ForwardDiff.jacobian(implicit, x) ≈ J","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"And so does Zygote.jl. Hurray!","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"Zygote.jacobian(implicit, x)[1] ≈ J","category":"page"},{"location":"examples/0_intro/#Second-derivative","page":"Introduction","title":"Second derivative","text":"","category":"section"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"We can even go higher-order by mixing the two packages (forward-over-reverse mode). The only technical requirement is to switch the linear solver to something that can handle dual numbers:","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"implicit_higher_order = ImplicitFunction(forward, conditions, DirectLinearSolver())","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"Then the Jacobian itself is differentiable.","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"h = rand(2)\nJ_Z(t) = Zygote.jacobian(implicit_higher_order, x .+ t .* h)[1]\nForwardDiff.derivative(J_Z, 0) ≈ Diagonal((-0.25 .* h) ./ (x .^ 1.5))","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"examples/0_intro/","page":"Introduction","title":"Introduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/3_tricks.jl\"","category":"page"},{"location":"examples/3_tricks/#Tricks","page":"Tricks","title":"Tricks","text":"","category":"section"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"We demonstrate several features that may come in handy for some users.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"using ComponentArrays\nusing ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Optim\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/3_tricks/#Multiple-arguments","page":"Tricks","title":"Multiple arguments","text":"","category":"section"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"First, we explain what to do when your forward mapping takes multiple input arguments:","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"y(a b) = undersety in mathbbR^mmathrmargmin  f(a b y)","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"The key idea is to store both a and b inside a single vector x.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"To make verification easy, we minimize the following objective:","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"f(a b y) = lVert y odot y - (a + 2b) rVert^2","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"In this case, the optimization problem boils down to the componentwise square root of a + 2b. We implement it with mutation to make sure that Zygote.jl will fail but ImplicitDifferentiation.jl will succeed.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"function mysqrt_components(a, b)\n    y = copy(a)\n    y .+= 2 .* b\n    y .= sqrt.(y)\n    return y\nend","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"First, we create the forward mapping which returns the solution y(x), where x is a ComponentVector containing both a and b.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"function forward_components(x)\n    return mysqrt_components(x.a, x.b)\nend","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"The optimality conditions are fairly easy to write.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"function conditions_components(x, y)\n    return @. 2(y^2 - (x.a + 2x.b))\nend","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"We now have all the ingredients to construct our implicit function.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"implicit_components = ImplicitFunction(forward_components, conditions_components)","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"And remember, we should only call it on a very specific type of vector:","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"x = ComponentVector(; a=rand(2), b=rand(2))","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"implicit_components(x) .^ 2","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Let's see what the explicit Jacobian looks like.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"J = hcat(Diagonal(0.5 ./ sqrt.(x.a + 2x.b)), 2 * Diagonal(0.5 ./ sqrt.(x.a + 2x.b)))","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Forward mode autodiff","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"ForwardDiff.jacobian(implicit_components, x)","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Reverse mode autodiff","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Zygote.jacobian(implicit_components, x)[1]","category":"page"},{"location":"examples/3_tricks/#Byproducts","page":"Tricks","title":"Byproducts","text":"","category":"section"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Next, we explain what to do when your forward mapping computes another object that you want to keep track of, which we will call its \"byproduct\". The difference between this and multiple outputs (which should be managed with ComponentArrays.jl) is that we do not compute derivatives with respect to byproducts.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Imagine a situation where, depending on a coin toss, said mapping either doubles or halves the input. After all, why not? For each individual run, the algorithmic derivative is well-defined. But to obtain it, you need to store the result of the toss.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"function forward_cointoss(x)\n    z = rand(Bool)\n    if z\n        y = 2x\n    else\n        y = x / 2\n    end\n    return y, z\nend","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"And naturally, the optimality condition also depends on the toss.","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"function conditions_cointoss(x, y, z)\n    if z\n        return y .- 2x\n    else\n        return 2y .- x\n    end\nend","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"To make sure that the implicit function you create takes this byproduct into account, just construct it like this:","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"implicit_cointoss = ImplicitFunction(\n    forward_cointoss, conditions_cointoss, HandleByproduct()\n)","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Then you have two ways of calling the function: the standard way will only return y","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"x = [1.0, 1.0]\n\nimplicit_cointoss(x)","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Or if you also need the byproduct, you can do","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"implicit_cointoss(x, ReturnByproduct())","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"But whatever you choose, the byproduct is taken into account during differentiation!","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"Zygote.withjacobian(implicit_cointoss, x)","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"","category":"page"},{"location":"examples/3_tricks/","page":"Tricks","title":"Tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Public","page":"API reference","title":"Public","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"ImplicitFunction","category":"page"},{"location":"api/#ImplicitDifferentiation.ImplicitFunction","page":"API reference","title":"ImplicitDifferentiation.ImplicitFunction","text":"ImplicitFunction{FF,CC,LS}\n\nDifferentiable wrapper for an implicit function defined by a forward mapping and a set of conditions.\n\nConstructors\n\nImplicitFunction(f, c)\nImplicitFunction(f, c, linear_solver)\nImplicitFunction(f, c, HandleByproduct())\nImplicitFunction(f, c, linear_solver, HandleByproduct())\n\nConstruct an ImplicitFunction from a forward mapping f and conditions c, both of which are Julia callables. While f does not not need to be compatible with automatic differentiation, c has to be.\n\nDetails\n\nBy default, we assume that the forward mapping is x -> y(x) and the conditions are c(x,y(x)) = 0.\nIf HandleByproduct() is passed as an argument to the constructor, we assume instead that the forward mapping is x -> (y(x),z(x)) and the conditions are c(x,y(x),z(x)) = 0. In this case, z(x) can contain additional information generated by the forward mapping, but beware that we consider it constant for differentiation purposes.\n\nGiven x ∈ ℝⁿ and y ∈ ℝᵈ, we need as many conditions as output dimensions: c(x,y,z) ∈ ℝᵈ. We can then compute the Jacobian of y(⋅) using the implicit function theorem:\n\n∂₂c(x,y(x),z(x)) * ∂y(x) = -∂₁c(x,y(x),z(x))\n\nThis requires solving a linear system A * J = -B, where A ∈ ℝᵈˣᵈ, B ∈ ℝᵈˣⁿ and J ∈ ℝᵈˣⁿ.\n\nFields\n\nforward::FF: a wrapper of type Forward around the callable f\nconditions::CC: a wrapper of type Conditions around the callable c\nlinear_solver::LS: an object subtyping AbstractLinearSolver (defaults to IterativeLinearSolver).\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"ImplicitDifferentiation.Forward\nImplicitDifferentiation.Conditions\nImplicitDifferentiation.PushforwardMul!\nImplicitDifferentiation.PullbackMul!","category":"page"},{"location":"api/#ImplicitDifferentiation.Forward","page":"API reference","title":"ImplicitDifferentiation.Forward","text":"Forward{byproduct,F}\n\nCallable wrapper for a forward mapping f::F, which ensures that a byproduct z(x) is always returned in addition to y(x).\n\nThe type parameter byproduct is a boolean stating whether or not f natively returns z(x).\n\n\n\n\n\n","category":"type"},{"location":"api/#ImplicitDifferentiation.Conditions","page":"API reference","title":"ImplicitDifferentiation.Conditions","text":"Conditions{byproduct,C}\n\nCallable wrapper for conditions c::C, which ensures that a byproduct z is always accepted in addition to x and y.\n\nThe type parameter byproduct is a boolean stating whether or not c natively accepts z.\n\n\n\n\n\n","category":"type"},{"location":"api/#ImplicitDifferentiation.PushforwardMul!","page":"API reference","title":"ImplicitDifferentiation.PushforwardMul!","text":"PushforwardMul!{P,N}\n\nCallable structure wrapping a pushforward with N-dimensional inputs into an in-place multiplication for vectors.\n\nFields\n\npushforward::P: the pushforward function\ninput_size::NTuple{N,Int}: the array size of the function input\n\n\n\n\n\n","category":"type"},{"location":"api/#ImplicitDifferentiation.PullbackMul!","page":"API reference","title":"ImplicitDifferentiation.PullbackMul!","text":"PullbackMul!{P,N}\n\nCallable structure wrapping a pullback with N-dimensional outputs into an in-place multiplication for vectors.\n\nFields\n\npullback::P: the pullback of the function\noutput_size::NTuple{N,Int}: the array size of the function output\n\n\n\n\n\n","category":"type"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/2_advanced.jl\"","category":"page"},{"location":"examples/2_advanced/#Advanced-use-cases","page":"Advanced use cases","title":"Advanced use cases","text":"","category":"section"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"We dive into more advanced applications of implicit differentiation:","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"constrained optimization problems","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Optim\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/2_advanced/#Constrained-optimization","page":"Advanced use cases","title":"Constrained optimization","text":"","category":"section"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"First, we show how to differentiate through the solution of a constrained optimization problem:","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"y(x) = undersety in mathbbR^mmathrmargmin  f(x y) quad textsubject to quad g(x y) leq 0","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"The optimality conditions are a bit trickier than in the previous cases. We can projection on the feasible set mathcalC(x) = y g(x y) leq 0  and exploit the convergence of projected gradient descent with step size eta:","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"y = mathrmproj_mathcalC(x) (y - eta nabla_2 f(x y))","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"To make verification easy, we minimize the following objective:","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"f(x y) = lVert y odot y - x rVert^2","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"on the hypercube mathcalC(x) = 0 1^n. In this case, the optimization problem boils down to a thresholded componentwise square root function, but we implement it using a black box solver from Optim.jl.","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"function forward_cstr_optim(x)\n    f(y) = sum(abs2, y .^ 2 - x)\n    lower = zeros(size(x))\n    upper = ones(size(x))\n    y0 = ones(eltype(x), size(x)) ./ 2\n    res = optimize(f, lower, upper, y0, Fminbox(GradientDescent()))\n    y = Optim.minimizer(res)\n    return y\nend","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"function proj_hypercube(p)\n    return max.(0, min.(1, p))\nend\n\nfunction conditions_cstr_optim(x, y)\n    ∇₂f = 2 .* (y .^ 2 .- x)\n    η = 0.1\n    return y .- proj_hypercube(y .- η .* ∇₂f)\nend","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"We now have all the ingredients to construct our implicit function.","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"implicit_cstr_optim = ImplicitFunction(forward_cstr_optim, conditions_cstr_optim)","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"And indeed, it behaves as it should when we call it:","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"x = rand(2) .+ [0, 1]","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"The second component of x is  1, so its square root will be thresholded to one, and the corresponding derivative will be 0.","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"implicit_cstr_optim(x) .^ 2","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"J_thres = Diagonal([0.5 / sqrt(x[1]), 0])","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"Forward mode autodiff","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"ForwardDiff.jacobian(implicit_cstr_optim, x)","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"ForwardDiff.jacobian(forward_cstr_optim, x)","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"Reverse mode autodiff","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"Zygote.jacobian(implicit_cstr_optim, x)[1]","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"try\n    Zygote.jacobian(forward_cstr_optim, x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"","category":"page"},{"location":"examples/2_advanced/","page":"Advanced use cases","title":"Advanced use cases","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ImplicitDifferentiation","category":"page"},{"location":"#ImplicitDifferentiation.jl","page":"Home","title":"ImplicitDifferentiation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ImplicitDifferentiation.jl is a package for automatic differentiation of functions defined implicitly, i.e., forward mappings","category":"page"},{"location":"","page":"Home","title":"Home","text":"x in mathbbR^n longmapsto y(x) in mathbbR^m","category":"page"},{"location":"","page":"Home","title":"Home","text":"whose output is defined by conditions","category":"page"},{"location":"","page":"Home","title":"Home","text":"c(xy(x)) = 0 in mathbbR^m","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Implicit differentiation is useful to differentiate through two types of functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Those for which automatic differentiation fails. Reasons can vary depending on your backend, but the most common include calls to external solvers, mutating operations or type restrictions.\nThose for which automatic differentiation is very slow. A common example is iterative procedures like fixed point equations or optimization algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please refer to Efficient and modular implicit differentiation for an introduction to the underlying theory.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the stable version, open a Julia REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"ImplicitDifferentiation\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the latest version, run this instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/gdalle/ImplicitDifferentiation.jl\")","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffOpt.jl: differentiation of convex optimization problems\nInferOpt.jl: approximate differentiation of combinatorial optimization problems\nNonconvexUtils.jl: contains the original implementation from which this package drew inspiration","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#Supported-autodiff-backends","page":"FAQ","title":"Supported autodiff backends","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Forward mode: ForwardDiff.jl\nReverse mode: all the packages compatible with ChainRules.jl","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In the future, we would like to add","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Enzyme.jl\nDiffractor.jl","category":"page"},{"location":"faq/#Higher-dimensional-arrays","page":"FAQ","title":"Higher-dimensional arrays","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For simplicity, our examples only display functions that eat and spit out vectors. However, arbitrary array shapes are supported, as long as the forward mapping and conditions return similar arrays. Beware however, sparse arrays will be densified in the differentiation process.","category":"page"},{"location":"faq/#Scalar-input-/-output","page":"FAQ","title":"Scalar input / output","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Functions that eat or spit out a single number are not supported. The forward mapping and conditions need arrays: for example, instead of returning value you should return [value] (a 1-element Vector).  Consider using an SVector from StaticArrays.jl if you seek increased performance.","category":"page"},{"location":"faq/#Multiple-inputs-/-outputs","page":"FAQ","title":"Multiple inputs / outputs","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In this package, implicit functions can only take a single input array x and output a single output array y (plus the byproduct z). But sometimes, your forward mapping or conditions may require multiple input arrays, say a and b:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"function f(a, b)\n    # do stuff\n    return y, z\nend","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In that case, you should gather the inputs inside a single ComponentVector from ComponentArrays.jl and define a new method:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"f(x::ComponentVector) = f(x.a, x.b)","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The same trick works for multiple outputs.","category":"page"},{"location":"faq/#Using-byproducts","page":"FAQ","title":"Using byproducts","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"At first glance, it is not obvious why we impose that the forward mapping should return a byproduct z in addition to y. It is mainly useful when the solution procedure creates objects such as Jacobians, which we want to reuse when computing or differentiating the conditions. We will provide simple examples soon. In the meantime, an advanced application is given by DifferentiableFrankWolfe.jl.","category":"page"},{"location":"faq/#Differentiating-byproducts","page":"FAQ","title":"Differentiating byproducts","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Nope. Sorry. Don't even think about it. The package is not designed to compute derivatives of z, only y, which is why the byproduct is considered constant during differentiation.","category":"page"},{"location":"faq/#Modeling-constrained-optimization-problems","page":"FAQ","title":"Modeling constrained optimization problems","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To express constrained optimization problems as implicit functions, you might need differentiable projections or proximal operators to write the optimality conditions. See Efficient and modular implicit differentiation for precise formulations.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In case these operators are too complicated to code them yourself, here are a few places you can look:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"MathOptSetDistances.jl\nProximalOperators.jl","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"An alternative is differentiating through the KKT conditions, which is exactly what DiffOpt.jl does for JuMP models.","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/1_basic.jl\"","category":"page"},{"location":"examples/1_basic/#Basic-use-cases","page":"Basic use cases","title":"Basic use cases","text":"","category":"section"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"We show how to differentiate through very common routines:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"an unconstrained optimization problem\na nonlinear system of equations\na fixed point iteration","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing NLsolve\nusing Optim\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"In all three cases, we will use the square root as our forward mapping, but expressed in three different ways. Here's our heroic test vector:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"x = rand(2);\nnothing #hide","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Since we already know the mathematical expression of the Jacobian, we will be able to compare it with our numerical results.","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"J = Diagonal(0.5 ./ sqrt.(x))","category":"page"},{"location":"examples/1_basic/#Unconstrained-optimization","page":"Basic use cases","title":"Unconstrained optimization","text":"","category":"section"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"First, we show how to differentiate through the solution of an unconstrained optimization problem:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"y(x) = undersety in mathbbR^mmathrmargmin  f(x y)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"The optimality conditions are given by gradient stationarity:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"nabla_2 f(x y) = 0","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"To make verification easy, we minimize the following objective:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"f(x y) = lVert y odot y - x rVert^2","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"In this case, the optimization problem boils down to the componentwise square root function, but we implement it using a black box solver from Optim.jl. Note the presence of a keyword argument.","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"function forward_optim(x; method)\n    f(y) = sum(abs2, y .^ 2 .- x)\n    y0 = ones(eltype(x), size(x))\n    result = optimize(f, y0, method)\n    return Optim.minimizer(result)\nend","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Even though they are defined as a gradient, it is better to provide optimality conditions explicitly: that way we avoid nesting autodiff calls. By default, the conditions should accept two arguments as input. The forward mapping and the conditions should accept the same set of keyword arguments.","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"function conditions_optim(x, y; method)\n    ∇₂f = 2 .* (y .^ 2 .- x)\n    return ∇₂f\nend","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"We now have all the ingredients to construct our implicit function.","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"implicit_optim = ImplicitFunction(forward_optim, conditions_optim)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"And indeed, it behaves as it should when we call it:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"implicit_optim(x; method=LBFGS()) .^ 2","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Forward mode autodiff","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"ForwardDiff.jacobian(_x -> implicit_optim(_x; method=LBFGS()), x)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"In this instance, we could use ForwardDiff.jl directly on the solver, but it returns the wrong result (not sure why).","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"ForwardDiff.jacobian(_x -> forward_optim(x; method=LBFGS()), x)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Reverse mode autodiff","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Zygote.jacobian(_x -> implicit_optim(_x; method=LBFGS()), x)[1]","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"In this instance, we cannot use Zygote.jl directly on the solver (due to unsupported try/catch statements).","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"try\n    Zygote.jacobian(_x -> forward_optim(x; method=LBFGS()), x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/1_basic/#Nonlinear-system","page":"Basic use cases","title":"Nonlinear system","text":"","category":"section"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Next, we show how to differentiate through the solution of a nonlinear system of equations:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"textfind quad y(x) quad textsuch that quad F(x y(x)) = 0","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"The optimality conditions are pretty obvious:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"F(x y) = 0","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"To make verification easy, we solve the following system:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"F(x y) = y odot y - x = 0","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"In this case, the optimization problem boils down to the componentwise square root function, but we implement it using a black box solver from NLsolve.jl.","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"function forward_nlsolve(x; method)\n    F!(storage, y) = (storage .= y .^ 2 - x)\n    initial_y = similar(x)\n    initial_y .= 1\n    result = nlsolve(F!, initial_y; method)\n    return result.zero\nend","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"function conditions_nlsolve(x, y; method)\n    c = y .^ 2 .- x\n    return c\nend","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"implicit_nlsolve = ImplicitFunction(forward_nlsolve, conditions_nlsolve)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"implicit_nlsolve(x; method=:newton) .^ 2","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Forward mode autodiff","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"ForwardDiff.jacobian(_x -> implicit_nlsolve(_x; method=:newton), x)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"ForwardDiff.jacobian(_x -> forward_nlsolve(_x; method=:newton), x)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Reverse mode autodiff","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Zygote.jacobian(_x -> implicit_nlsolve(_x; method=:newton), x)[1]","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"try\n    Zygote.jacobian(_x -> forward_nlsolve(_x; method=:newton), x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/1_basic/#Fixed-point","page":"Basic use cases","title":"Fixed point","text":"","category":"section"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Finally, we show how to differentiate through the limit of a fixed point iteration:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"y longmapsto T(x y)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"The optimality conditions are pretty obvious:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"y = T(x y)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"To make verification easy, we consider Heron's method:","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"T(x y) = frac12 left(y + fracxyright)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"In this case, the fixed point algorithm boils down to the componentwise square root function, but we implement it manually.","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"function forward_fixedpoint(x; iterations)\n    y = ones(eltype(x), size(x))\n    for _ in 1:iterations\n        y .= 0.5 .* (y .+ x ./ y)\n    end\n    return y\nend","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"function conditions_fixedpoint(x, y; iterations)\n    T = 0.5 .* (y .+ x ./ y)\n    return T .- y\nend","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"implicit_fixedpoint = ImplicitFunction(forward_fixedpoint, conditions_fixedpoint)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"implicit_fixedpoint(x; iterations=10) .^ 2","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Forward mode autodiff","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"ForwardDiff.jacobian(_x -> implicit_fixedpoint(_x; iterations=10), x)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"ForwardDiff.jacobian(_x -> forward_fixedpoint(_x; iterations=10), x)","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Reverse mode autodiff","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"Zygote.jacobian(_x -> implicit_fixedpoint(_x; iterations=10), x)[1]","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"try\n    Zygote.jacobian(_x -> forward_fixedpoint(_x; iterations=10), x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"","category":"page"},{"location":"examples/1_basic/","page":"Basic use cases","title":"Basic use cases","text":"This page was generated using Literate.jl.","category":"page"}]
}
