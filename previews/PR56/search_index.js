var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ImplicitDifferentiation]","category":"page"},{"location":"api/#ImplicitDifferentiation.ImplicitFunction","page":"API reference","title":"ImplicitDifferentiation.ImplicitFunction","text":"ImplicitFunction{F,C,L}\n\nDifferentiable wrapper for an implicit function x -> y(x) whose output is defined by conditions F(x,y(x)) = 0.\n\nMore generally, we consider functions x -> (y(x),z(x)) and conditions F(x,y(x),z(x)) = 0, where z(x) contains additional information that is considered constant for differentiation purposes.\n\nIf x ∈ ℝⁿ and y ∈ ℝᵈ, then we need as many conditions as output dimensions: F(x,y,z) ∈ ℝᵈ. Thanks to these conditions, we can compute the Jacobian of y(⋅) using the implicit function theorem:\n\n∂₂F(x,y(x),z(x)) * ∂y(x) = -∂₁F(x,y(x),z(x))\n\nThis amounts to solving a linear system A * J = -B, where A ∈ ℝᵈˣᵈ, B ∈ ℝᵈˣⁿ and J ∈ ℝᵈˣⁿ.\n\nFields:\n\nforward::F: callable of the form x -> (ŷ(x),z(x)).\nconditions::C: callable of the form (x,y,z) -> F(x,y,z)\nlinear_solver::L: callable of the form (A,b) -> u such that Au = b, must be taken from Krylov.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#ImplicitDifferentiation.ImplicitFunction-Tuple{Any, Any}","page":"API reference","title":"ImplicitDifferentiation.ImplicitFunction","text":"ImplicitFunction(forward, conditions)\n\nConstruct an ImplicitFunction with Krylov.gmres as the default linear solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#ImplicitDifferentiation.ImplicitFunction-Union{Tuple{Any}, Tuple{return_byproduct}, Tuple{Any, Val{return_byproduct}}} where return_byproduct","page":"API reference","title":"ImplicitDifferentiation.ImplicitFunction","text":"implicit(x[; kwargs...])\n\nMake ImplicitFunction callable by applying implicit.forward.\n\n\n\n\n\n","category":"method"},{"location":"api/#ImplicitDifferentiation.PullbackMul!","page":"API reference","title":"ImplicitDifferentiation.PullbackMul!","text":"PullbackMul!{P,N}\n\nCallable structure wrapping a pullback with N-dimensional outputs into an in-place multiplication for vectors.\n\nFields\n\npullback::P: the pullback of the function\noutput_size::NTuple{N,Int}: the array size of the function output\n\n\n\n\n\n","category":"type"},{"location":"api/#ImplicitDifferentiation.PushforwardMul!","page":"API reference","title":"ImplicitDifferentiation.PushforwardMul!","text":"PushforwardMul!{P,N}\n\nCallable structure wrapping a pushforward with N-dimensional inputs into an in-place multiplication for vectors.\n\nFields\n\npushforward::P: the pushforward function\ninput_size::NTuple{N,Int}: the array size of the function input\n\n\n\n\n\n","category":"type"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/1_unconstrained_optim.jl\"","category":"page"},{"location":"examples/1_unconstrained_optim/#Unconstrained-optimization","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"","category":"section"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"In this example, we show how to differentiate through the solution of an unconstrained optimization problem:","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"y(x) = undersety in mathbbR^mmathrmargmin  f(x y)","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"The optimality conditions are given by gradient stationarity:","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"nabla_2 f(x y) = 0","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Optim\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/1_unconstrained_optim/#Implicit-function","page":"Unconstrained optimization","title":"Implicit function","text":"","category":"section"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"To make verification easy, we minimize the following objective:","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"f(x y) = lVert y odot y - x rVert^2","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"In this case, the optimization problem boils down to the componentwise square root function, but we implement it using a black box solver from Optim.jl. Note the presence of a keyword argument.","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"function mysqrt_optim(x; method)\n    f(y) = sum(abs2, y .^ 2 .- x)\n    y0 = ones(eltype(x), size(x))\n    result = optimize(f, y0, method)\n    return Optim.minimizer(result)\nend","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"First, we create the forward pass which returns the solution y(x). Remember that it should also return additional information z(x), which is useless here.","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"function forward_optim(x; method)\n    y = mysqrt_optim(x; method)\n    z = 0\n    return y, z\nend","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"Even though they are defined as a gradient, it is better to provide optimality conditions explicitly: that way we avoid nesting autodiff calls. Remember, the conditions should accept three arguments to take additional information into account when needed. Moreover, the forward pass and the conditions should accept the same set of keyword arguments.","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"function conditions_optim(x, y, z; method)\n    ∇₂f = 2 .* (y .^ 2 .- x)\n    return ∇₂f\nend","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"We now have all the ingredients to construct our implicit function.","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"implicit_optim = ImplicitFunction(forward_optim, conditions_optim)","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"And indeed, it behaves as it should when we call it:","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"x = rand(2)","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"implicit_optim(x; method=LBFGS()) .^ 2","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"Let's see what the explicit Jacobian looks like.","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"J = Diagonal(0.5 ./ sqrt.(x))","category":"page"},{"location":"examples/1_unconstrained_optim/#Forward-mode-autodiff","page":"Unconstrained optimization","title":"Forward mode autodiff","text":"","category":"section"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"ForwardDiff.jacobian(_x -> implicit_optim(_x; method=LBFGS()), x)","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"Unsurprisingly, the Jacobian is the identity. In this instance, we could use ForwardDiff.jl directly on the solver, but it returns the wrong result (not sure why).","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"ForwardDiff.jacobian(_x -> mysqrt_optim(x; method=LBFGS()), x)","category":"page"},{"location":"examples/1_unconstrained_optim/#Reverse-mode-autodiff","page":"Unconstrained optimization","title":"Reverse mode autodiff","text":"","category":"section"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"Zygote.jacobian(_x -> implicit_optim(_x; method=LBFGS()), x)[1]","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"Again, the Jacobian is the identity. In this instance, we cannot use Zygote.jl directly on the solver (due to unsupported try/catch statements).","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"try\n    Zygote.jacobian(_x -> mysqrt_optim(x; method=LBFGS()), x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"","category":"page"},{"location":"examples/1_unconstrained_optim/","page":"Unconstrained optimization","title":"Unconstrained optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/5_multiargs.jl\"","category":"page"},{"location":"examples/5_multiargs/#Multiple-arguments","page":"Multiple arguments","title":"Multiple arguments","text":"","category":"section"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"In this example, we explain what to do when your function takes multiple input arguments:","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"y(a b) = undersety in mathbbR^mmathrmargmin  f(a b y)","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"The key idea is to store both a and b inside a single vector x.","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"using ComponentArrays\nusing ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Optim\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/5_multiargs/#Implicit-function","page":"Multiple arguments","title":"Implicit function","text":"","category":"section"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"To make verification easy, we minimize the following objective:","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"f(a b y) = lVert y odot y - (a + 2b) rVert^2","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"In this case, the optimization problem boils down to the componentwise square root of a + 2b. We implement it with mutation to make sure that Zygote.jl will fail but ImplicitDifferentiation.jl will succeed.","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"function mysqrt_components(a, b)\n    y = copy(a)\n    y .+= 2 .* b\n    y .= sqrt.(y)\n    return y\nend","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"First, we create the forward pass which returns the solution y(x), where x is a ComponentVector containing both a and b.","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"function forward_components(x)\n    y = mysqrt_components(x.a, x.b)\n    z = 0\n    return y, z\nend","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"The optimality conditions are fairly easy to write.","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"function conditions_components(x, y, z)\n    return @. 2(y^2 - (x.a + 2x.b))\nend","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"We now have all the ingredients to construct our implicit function.","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"implicit_components = ImplicitFunction(forward_components, conditions_components)","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"And remember, we should only call it on a very specific type of vector:","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"x = ComponentVector(; a=rand(2), b=rand(2))","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"implicit_components(x) .^ 2","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"Let's see what the explicit Jacobian looks like.","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"J = hcat(Diagonal(0.5 ./ sqrt.(x.a + 2x.b)), 2 * Diagonal(0.5 ./ sqrt.(x.a + 2x.b)))","category":"page"},{"location":"examples/5_multiargs/#Forward-mode-autodiff","page":"Multiple arguments","title":"Forward mode autodiff","text":"","category":"section"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"ForwardDiff.jacobian(implicit_components, x)","category":"page"},{"location":"examples/5_multiargs/#Reverse-mode-autodiff","page":"Multiple arguments","title":"Reverse mode autodiff","text":"","category":"section"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"Zygote.jacobian(implicit_components, x)[1]","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"","category":"page"},{"location":"examples/5_multiargs/","page":"Multiple arguments","title":"Multiple arguments","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/3_fixed_points.jl\"","category":"page"},{"location":"examples/3_fixed_points/#Fixed-point","page":"Fixed point","title":"Fixed point","text":"","category":"section"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"In this example, we show how to differentiate through the limit of a fixed point iteration:","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"y longmapsto T(x y)","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"The optimality conditions are pretty obvious:","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"y = T(x y)","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/3_fixed_points/#Implicit-function","page":"Fixed point","title":"Implicit function","text":"","category":"section"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"To make verification easy, we consider Heron's method:","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"T(x y) = frac12 left(y + fracxyright)","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"In this case, the fixed point algorithm boils down to the componentwise square root function, but we implement it manually.","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"function mysqrt_fixedpoint(x; iterations)\n    y = ones(eltype(x), size(x))\n    for _ in 1:iterations\n        y .= 0.5 .* (y .+ x ./ y)\n    end\n    return y\nend","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"function forward_fixedpoint(x; iterations)\n    y = mysqrt_fixedpoint(x; iterations)\n    z = 0\n    return y, z\nend","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"function conditions_fixedpoint(x, y, z; iterations)\n    T = 0.5 .* (y .+ x ./ y)\n    return T .- y\nend","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"implicit_fixedpoint = ImplicitFunction(forward_fixedpoint, conditions_fixedpoint)","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"x = rand(2)","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"implicit_fixedpoint(x; iterations=10) .^ 2","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"J = Diagonal(0.5 ./ sqrt.(x))","category":"page"},{"location":"examples/3_fixed_points/#Forward-mode-autodiff","page":"Fixed point","title":"Forward mode autodiff","text":"","category":"section"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"ForwardDiff.jacobian(_x -> implicit_fixedpoint(_x; iterations=10), x)","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"ForwardDiff.jacobian(_x -> mysqrt_fixedpoint(_x; iterations=10), x)","category":"page"},{"location":"examples/3_fixed_points/#Reverse-mode-autodiff","page":"Fixed point","title":"Reverse mode autodiff","text":"","category":"section"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"Zygote.jacobian(_x -> implicit_fixedpoint(_x; iterations=10), x)[1]","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"try\n    Zygote.jacobian(_x -> mysqrt_fixedpoint(_x; iterations=10), x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"","category":"page"},{"location":"examples/3_fixed_points/","page":"Fixed point","title":"Fixed point","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/4_constrained_optim.jl\"","category":"page"},{"location":"examples/4_constrained_optim/#Constrained-optimization","page":"Constrained optimization","title":"Constrained optimization","text":"","category":"section"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"In this example, we show how to differentiate through the solution of a constrained optimization problem:","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"y(x) = undersety in mathbbR^mmathrmargmin  f(x y) quad textsubject to quad g(x y) leq 0","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"The optimality conditions are a bit trickier than in the previous cases. We can projection on the feasible set mathcalC(x) = y g(x y) leq 0  and exploit the convergence of projected gradient descent with step size eta:","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"y = mathrmproj_mathcalC(x) (y - eta nabla_2 f(x y))","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Optim\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/4_constrained_optim/#Implicit-function","page":"Constrained optimization","title":"Implicit function","text":"","category":"section"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"To make verification easy, we minimize the following objective:","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"f(x y) = lVert y odot y - x rVert^2","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"on the hypercube mathcalC(x) = 0 1^n. In this case, the optimization problem boils down to a thresholded componentwise square root function, but we implement it using a black box solver from Optim.jl.","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"function mysqrt_cstr_optim(x)\n    f(y) = sum(abs2, y .^ 2 - x)\n    lower = zeros(size(x))\n    upper = ones(size(x))\n    y0 = ones(eltype(x), size(x)) ./ 2\n    res = optimize(f, lower, upper, y0, Fminbox(GradientDescent()))\n    y = Optim.minimizer(res)\n    return y\nend","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"function forward_cstr_optim(x)\n    y = mysqrt_cstr_optim(x)\n    z = 0\n    return y, z\nend","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"function proj_hypercube(p)\n    return max.(0, min.(1, p))\nend\n\nfunction conditions_cstr_optim(x, y, z)\n    ∇₂f = 2 .* (y .^ 2 .- x)\n    η = 0.1\n    return y .- proj_hypercube(y .- η .* ∇₂f)\nend","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"We now have all the ingredients to construct our implicit function.","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"implicit_cstr_optim = ImplicitFunction(forward_cstr_optim, conditions_cstr_optim)","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"And indeed, it behaves as it should when we call it:","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"x = rand(2) .+ [0, 1]","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"The second component of x is  1, so its square root will be thresholded to one, and the corresponding derivative will be 0.","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"implicit_cstr_optim(x) .^ 2","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"J_thres = Diagonal([0.5 / sqrt(x[1]), 0])","category":"page"},{"location":"examples/4_constrained_optim/#Forward-mode-autodiff","page":"Constrained optimization","title":"Forward mode autodiff","text":"","category":"section"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"ForwardDiff.jacobian(implicit_cstr_optim, x)","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"ForwardDiff.jacobian(mysqrt_cstr_optim, x)","category":"page"},{"location":"examples/4_constrained_optim/#Reverse-mode-autodiff","page":"Constrained optimization","title":"Reverse mode autodiff","text":"","category":"section"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"Zygote.jacobian(implicit_cstr_optim, x)[1]","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"try\n    Zygote.jacobian(mysqrt_cstr_optim, x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"","category":"page"},{"location":"examples/4_constrained_optim/","page":"Constrained optimization","title":"Constrained optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/2_nonlinear_solve.jl\"","category":"page"},{"location":"examples/2_nonlinear_solve/#Nonlinear-solve","page":"Nonlinear solve","title":"Nonlinear solve","text":"","category":"section"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"In this example, we show how to differentiate through the solution of a nonlinear system of equations:","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"textfind quad y(x) quad textsuch that quad F(x y(x)) = 0","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"The optimality conditions are pretty obvious:","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"F(x y) = 0","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing NLsolve\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/2_nonlinear_solve/#Implicit-function","page":"Nonlinear solve","title":"Implicit function","text":"","category":"section"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"To make verification easy, we solve the following system:","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"F(x y) = y odot y - x = 0","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"In this case, the optimization problem boils down to the componentwise square root function, but we implement it using a black box solver from NLsolve.jl.","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"function mysqrt_nlsolve(x; method)\n    F!(storage, y) = (storage .= y .^ 2 - x)\n    initial_y = ones(eltype(x), size(x))\n    result = nlsolve(F!, initial_y; method)\n    return result.zero\nend","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"function forward_nlsolve(x; method)\n    y = mysqrt_nlsolve(x; method)\n    z = 0\n    return y, z\nend","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"function conditions_nlsolve(x, y, z; method)\n    F = y .^ 2 .- x\n    return F\nend","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"implicit_nlsolve = ImplicitFunction(forward_nlsolve, conditions_nlsolve)","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"x = rand(2)","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"implicit_nlsolve(x; method=:newton) .^ 2","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"J = Diagonal(0.5 ./ sqrt.(x))","category":"page"},{"location":"examples/2_nonlinear_solve/#Forward-mode-autodiff","page":"Nonlinear solve","title":"Forward mode autodiff","text":"","category":"section"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"ForwardDiff.jacobian(_x -> implicit_nlsolve(_x; method=:newton), x)","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"ForwardDiff.jacobian(_x -> mysqrt_nlsolve(_x; method=:newton), x)","category":"page"},{"location":"examples/2_nonlinear_solve/#Reverse-mode-autodiff","page":"Nonlinear solve","title":"Reverse mode autodiff","text":"","category":"section"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"Zygote.jacobian(_x -> implicit_nlsolve(_x; method=:newton), x)[1]","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"try\n    Zygote.jacobian(_x -> mysqrt_nlsolve(_x; method=:newton), x)[1]\ncatch e\n    e\nend","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"","category":"page"},{"location":"examples/2_nonlinear_solve/","page":"Nonlinear solve","title":"Nonlinear solve","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ImplicitDifferentiation","category":"page"},{"location":"#ImplicitDifferentiation.jl","page":"Home","title":"ImplicitDifferentiation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ImplicitDifferentiation.jl is a package for automatic differentiation of functions defined implicitly, i.e., mappings","category":"page"},{"location":"","page":"Home","title":"Home","text":"x in mathbbR^n longmapsto y(x) in mathbbR^m","category":"page"},{"location":"","page":"Home","title":"Home","text":"whose output is defined by conditions","category":"page"},{"location":"","page":"Home","title":"Home","text":"F(xy(x)) = 0 in mathbbR^m","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Implicit differentiation is useful to differentiate through two types of functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Those for which automatic differentiation fails. Reasons can vary depending on your backend, but the most common include calls to external solvers, mutating operations or type restrictions.\nThose for which automatic differentiation is very slow. A common example is iterative procedures like fixed point equations or optimization algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please refer to Efficient and modular implicit differentiation for an introduction to the underlying theory.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the stable version, open a Julia REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"ImplicitDifferentiation\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the latest version, run this instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/gdalle/ImplicitDifferentiation.jl\")","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffOpt.jl: differentiation of convex optimization problems\nInferOpt.jl: approximate differentiation of combinatorial optimization problems\nNonconvexUtils.jl: contains the original implementation from which this package drew inspiration","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#Supported-autodiff-backends","page":"FAQ","title":"Supported autodiff backends","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Forward mode: ForwardDiff.jl\nReverse mode: all the packages compatible with ChainRules.jl","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In the future, we would like to add Enzyme.jl support.","category":"page"},{"location":"faq/#Higher-dimensional-arrays","page":"FAQ","title":"Higher-dimensional arrays","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For simplicity, our examples only display functions that eat and spit out vectors. However, arbitrary array shapes are supported, as long as the forward and conditions callables return similar arrays. Beware however, sparse arrays will be densified in the differentiation process.","category":"page"},{"location":"faq/#Scalar-input-/-output","page":"FAQ","title":"Scalar input / output","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Functions that eat or spit out a single number are not supported. The forward and conditions callables need arrays: for example, instead of returning value you should return [value] (a 1-element Vector).  Consider using an SVector from StaticArrays.jl if you seek increased performance.","category":"page"},{"location":"faq/#Multiple-inputs-/-outputs","page":"FAQ","title":"Multiple inputs / outputs","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In this package, implicit functions can only take a single input array x and output a single output array y (plus the additional info z). But sometimes, your forward pass or conditions may require multiple input arrays, say a and b:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"function f(a, b)\n    # do stuff\n    return y, z\nend","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In that case, you should gather the inputs inside a single ComponentVector from ComponentArrays.jl and define a new method:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"f(x::ComponentVector) = f(x.a, x.b)","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The same trick works for multiple outputs.","category":"page"},{"location":"faq/#Modeling-constrained-optimization-problems","page":"FAQ","title":"Modeling constrained optimization problems","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To express constrained optimization problems as implicit functions, you might need differentiable projections or proximal operators to write the optimality conditions. See Efficient and modular implicit differentiation for precise formulations.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In case these operators are too complicated to code them yourself, here are a few places you can look:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"MathOptSetDistances.jl\nProximalOperators.jl","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"An alternative is differentiating through the KKT conditions, which is exactly what DiffOpt.jl does for JuMP models.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"EditURL = \"https://github.com/gdalle/ImplicitDifferentiation.jl/blob/main/examples/0_basic.jl\"","category":"page"},{"location":"examples/0_basic/#Basic-use","page":"Basic use","title":"Basic use","text":"","category":"section"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"In this example, we demonstrate the basics of our package on a simple function that is not amenable to automatic differentiation.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"using ForwardDiff\nusing ImplicitDifferentiation\nusing LinearAlgebra\nusing Random\nusing Zygote\n\nRandom.seed!(63);\nnothing #hide","category":"page"},{"location":"examples/0_basic/#Why-do-we-bother?","page":"Basic use","title":"Why do we bother?","text":"","category":"section"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"ForwardDiff.jl and Zygote.jl are two prominent packages for automatic differentiation in Julia. While they are very generic, there are simple language constructs that they cannot differentiate through.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"function mysqrt(x::AbstractArray)\n    a = [0.0]\n    a[1] = first(x)\n    return sqrt.(x)\nend","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"This is essentially the componentwise square root function but with an additional twist: a::Vector{Float64} is created internally, and its only element is replaced with the first element of x. We can check that it does what it's supposed to do.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"x = rand(2)\nmysqrt(x) ≈ sqrt.(x)","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"Of course the Jacobian has an explicit formula.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"J = Diagonal(0.5 ./ sqrt.(x))","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"However, things start to go wrong when we compute it with autodiff, due to the limitations of ForwardDiff.jl and those of Zygote.jl.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"try\n    ForwardDiff.jacobian(mysqrt, x)\ncatch e\n    e\nend","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"ForwardDiff.jl throws an error because it tries to call mysqrt with an array of dual numbers, and cannot use one of these numbers to fill a (which has element type Float64).","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"try\n    Zygote.jacobian(mysqrt, x)\ncatch e\n    e\nend","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"Zygote.jl also throws an error because it cannot handle mutation.","category":"page"},{"location":"examples/0_basic/#Implicit-function","page":"Basic use","title":"Implicit function","text":"","category":"section"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"The first possible use of ImplicitDifferentiation.jl is to overcome the limitations of automatic differentiation packages by defining functions (and computing their derivatives) implicitly. An implicit function is a mapping","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"x in mathbbR^n longmapsto y(x) in mathbbR^m","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"whose output is defined by conditions","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"F(xy(x)) = 0 in mathbbR^m","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"We represent it using a type called ImplicitFunction, which you will see in action shortly.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"First we define a forward pass correponding to the function we consider. It returns the actual output y(x) of the function, as well as the optional additional information z(x). Here we don't need any additional information, so we set it to 0. Importantly, this forward pass doesn't need to be differentiable.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"function forward(x)\n    y = mysqrt(x)\n    z = 0\n    return y, z\nend","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"Then we define conditions F(x y z) = 0 that the output y(x) is supposed to satisfy. These conditions must be array-valued, with the same size as y, and take z as an additional argument. And unlike the forward pass, the conditions need to be differentiable with respect to x and y. Here they are very obvious: the square of the square root should be equal to the original value.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"function conditions(x, y, z)\n    c = y .^ 2 .- x\n    return c\nend","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"Finally, we construct a wrapper implicit around the previous objects. What does this wrapper do?","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"implicit = ImplicitFunction(forward, conditions)","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"When we call it as a function, it just falls back on first ∘ implicit.forward, so unsurprisingly we get the first output y(x).","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"implicit(x) ≈ sqrt.(x)","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"And when we try to compute its Jacobian, the implicit function theorem is applied in the background to circumvent the lack of differentiablility of the forward pass.","category":"page"},{"location":"examples/0_basic/#Forward-and-reverse-mode-autodiff","page":"Basic use","title":"Forward and reverse mode autodiff","text":"","category":"section"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"Now ForwardDiff.jl works seamlessly.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"ForwardDiff.jacobian(implicit, x) ≈ J","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"And so does Zygote.jl. Hurray!","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"Zygote.jacobian(implicit, x)[1] ≈ J","category":"page"},{"location":"examples/0_basic/#Second-derivative","page":"Basic use","title":"Second derivative","text":"","category":"section"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"We can even go higher-order by mixing the two packages (forward-over-reverse mode). The only technical requirement is to switch the linear solver to something that can handle dual numbers:","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"linear_solver(A, b) = (Matrix(A) \\ b, (solved=true,))\nimplicit2 = ImplicitFunction(forward, conditions, linear_solver)","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"Then the Jacobian itself is differentiable.","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"h = rand(2)\nJ_Z(t) = Zygote.jacobian(implicit2, x .+ t .* h)[1]\nForwardDiff.derivative(J_Z, 0) ≈ Diagonal((-0.25 .* h) ./ (x .^ 1.5))","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"","category":"page"},{"location":"examples/0_basic/","page":"Basic use","title":"Basic use","text":"This page was generated using Literate.jl.","category":"page"}]
}
